### 1. Понятие шаблона проектирования, составляющие шаблона. Приведите примеры употребления шаблонов в неверных контекстах

Концепция шаблона проектирования относится к повторно используемому решению общей проблемы в разработке программного обеспечения. Он предоставляет шаблон или схему решения конкретной проблемы, позволяя разработчикам использовать проверенные подходы и лучшие практики.

Компоненты шаблона проектирования обычно включают:

1. Название шаблона: описательный заголовок, отражающий суть шаблона.
2. Проблема. Конкретная проблема или проблема, которую решает шаблон.
3. Решение. Рекомендуемое решение проблемы, часто отображаемое в виде схемы или фрагмента кода.
4. Последствия: компромиссы и последствия реализации шаблона.
5. Контекст: условия, при которых шаблон наиболее эффективен и подходит.

Вот несколько примеров использования шаблонов проектирования в неправильном контексте:

1. Шаблон Singleton для управления несколькими экземплярами:
   Шаблон Singleton используется для обеспечения существования только одного экземпляра класса. Однако если вам нужно управлять несколькими экземплярами класса, попытка принудительно использовать шаблон Singleton в этом контексте приведет к неправильному поведению и сведет на нет цель шаблона.

2. Шаблон наблюдателя для простой обработки событий:
   Паттерн Наблюдатель используется для установления отношения «один ко многим» между объектами, когда изменения в одном объекте вызывают обновления в нескольких зависимых объектах. Если у вас есть простой сценарий обработки событий с несколькими прослушивателями или наблюдателями, использование шаблона Observer может привести к ненужной сложности и накладным расходам.

3. Шаблон декоратора для крупномасштабной композиции объектов:
   Шаблон Decorator используется для динамического добавления функциональности к объекту путем включения в него одного или нескольких декораторов. Однако, если у вас есть крупномасштабный сценарий композиции объектов с многочисленными декораторами и сложными взаимодействиями, сильное использование шаблона декоратора может привести к запутанной и сложной в обслуживании кодовой базе.

4. Шаблон фабричного метода для одного продукта:
   Шаблон Factory Method используется для создания объектов без указания их точного класса. Однако если у вас есть ситуация, когда вам нужно создать объект только одного типа, использование шаблона фабричного метода может привести к ненужной сложности и затруднить понимание кода.

5. Шаблон моста для простой абстракции и реализации:
   Шаблон Bridge используется для отделения абстракции от ее реализации, что позволяет им изменяться независимо друг от друга. Если у вас есть простой сценарий с одной абстракцией и реализацией, введение шаблона Bridge может добавить ненужные уровни абстракции и усложнить кодовую базу, не предоставив значительных преимуществ.

---

### 2. Классификация паттернов проектирования, приведите несколько примеров паттернов каждого класса

Порождающие:
Фабричный метод, Синглтон, Строитель.

Структурные:
Адаптер, Декоратор, Прокси.

Поведенческие:
Наблюдатель, Стратегия, Шаблонный метод.

Архитектурные шаблоны:

-  (MVC): разделяет логику представления, данных и взаимодействия с пользователем приложения на три отдельных компонента.
-  Многоуровневая архитектура: приложение организуется в разные слои, каждый из которых отвечает за определенный набор функций, что способствует модульности и разделению задач (Atomic или Featured Sliced Designs).
-  Микросервисы: разбивает большое приложение на набор небольших, слабо связанных сервисов, которые взаимодействуют друг с другом через API (вспоминаем Kubernetes).

Паттерны конкурентности:

-  Мьютекс: синхронизирует доступ к общему ресурсу, позволяя только одному потоку или процессу получить его блокировку за раз.
-  Блокировка чтения-записи: позволяет нескольким читателям одновременно обращаться к общему ресурсу, предоставляя эксклюзивный доступ одному писателю.
-  Производитель-потребитель: координирует взаимодействие между несколькими потоками-производителями и потоками-потребителями для безопасного совместного использования ограниченного буфера.

---

### 3. Функциональные интерфейсы. Понятие функционального интерфейса и использование в программах на языке Джава

В Java функциональный интерфейс — это интерфейс, который имеет ровно один абстрактный метод.

```java
@FunctionalInterface // Необязательно
interface Calculator {
	int calculate(int a, int b);
}

Calculator addition = (a, b) -> a + b;
int result = addition.calculate(3, 5); // result = 8

Calculator subtraction = (a, b) -> a - b;
result = subtraction.calculate(8, 3); // result = 5

void performOperation(Calculator calculator) {
	int result = calculator.calculate(5, 3);
}

Calculator getCalculator() {
	return (a, b) -> a * b;
}
```

---

### 4. Определение и использование функциональных интерфейсов. Аннотирование функциональных интерфейсов

См пункт 3

---

### 5. Понятие и использование лямбда -выражений в языке Джава. Примеры

Лямбда-выражения — это конструкция, которая позволяет вам кратко выражать анонимные функции

Синтаксис лямбда-выражения состоит из трех основных частей:

1. Список параметров: определяет входные параметры анонимной функции.
2. Маркер стрелки (`->`): отделяет список параметров от тела лямбда-выражения.
3. Тело: содержит реализацию анонимной функции.

Примеры:

```Java
Runnable runnable = () -> {
   System.out.println("Executing a task");
   // Additional logic
};
```

```Java
List<String> names = Arrays.asList("John", "Alice", "Bob");
Collections.sort(names, (a, b) -> a.compareTo(b));
```

```Java
button.addActionListener(event -> {
   // Handle button click event
});
```

```Java
@FunctionalInterface
interface Calculator {
   int calculate(int a, int b);
}

Calculator addition = (a, b) -> a + b;
int result = addition.calculate(3, 5); // result = 8
```

---

### 6. Паттерн Стратегия. Пример использования функций для параметризации поведения объектов

Шаблон Strategy — это поведенческий шаблон проектирования, который позволяет определить семейство алгоритмов, инкапсулировать каждый из них в виде отдельного класса и сделать их взаимозаменяемыми во время выполнения. Он позволяет параметризовать поведение объектов, определяя стратегии или алгоритмы как отдельные объекты и предоставляя способ динамического переключения между ними.

Обычный способ реализации шаблона Strategy в Java — использование функциональных интерфейсов и лямбда-выражений. Определив функциональные интерфейсы для представления стратегий и используя лямбда-выражения, вы можете легко параметризовать поведение объектов.

```java
@FunctionalInterface
interface SortingStrategy {
   void sort(int[] array);
}

class BubbleSortStrategy implements SortingStrategy {
   @Override
   public void sort(int[] array) {
      // Implementation of bubble sort algorithm
   }
}

class QuickSortStrategy implements SortingStrategy {
   @Override
   public void sort(int[] array) {
      // Implementation of quicksort algorithm
   }
}

class Sorter {
   private SortingStrategy sortingStrategy;

   public void setSortingStrategy(SortingStrategy sortingStrategy) {
      this.sortingStrategy = sortingStrategy;
   }

   public void sortArray(int[] array) {
      sortingStrategy.sort(array);
   }
}

public class Main {
   public static void main(String[] args) {
      int[] array = {5, 2, 8, 1, 9};

      Sorter sorter = new Sorter();

      sorter.setSortingStrategy(new BubbleSortStrategy());
      sorter.sortArray(array);
      // Array sorted using bubble sort strategy

      sorter.setSortingStrategy(new QuickSortStrategy());
      sorter.sortArray(array);
      // Array sorted using quicksort strategy
   }
}
```

---

### 7. Понятие чистой функции. Побочные эффекты функций. Чистота функций в ООП. Пример

Характеристики чистой функции:

1. Выдает один и тот же результат для одних и тех же входных данных, независимо от того, когда и сколько раз она вызывается
2. Отсутствие побочных эффектов. Чистая функция не изменяет и не мутирует какие-либо данные за пределами своей области.

```java
class Calculator {
   public int add(int a, int b) {
      return a + b;
   }
}

public class Main {
   public static void main(String[] args) {
      Calculator calculator = new Calculator();
      int result = calculator.add(3, 5);
      System.out.println(result); // Output: 8
   }
}
```

---

### 8. Неизменяемый класс. Преимущества использования неизменяемых классов. Пример

Неизменный класс в Java — это класс, экземпляры которого не могут быть изменены после их создания.

Преимущества:

1. Потокобезопасность. Неизменяемые объекты по своей сути являются потокобезопасными, поскольку их нельзя изменить.
2. Простота и надежность. Благодаря неизменности вам легче рассуждать об объектах, поскольку их состояние остается постоянным.
3. Непротиворечивость. Неизменяемые объекты гарантируют, что их состояние останется согласованным на протяжении всего их жизненного цикла.
4. Кэшируемость. Неизменяемые объекты можно безопасно кэшировать и использовать повторно, поскольку их состояние не меняется.
5. Неизменяемые объекты могут свободно использоваться различными компонентами приложения.

```java
public final class Point {
   private final int x;
   private final int y;

   public Point(int x, int y) {
      this.x = x;
      this.y = y;
   }

   public int getX() {
      return x;
   }

   public int getY() {
      return y;
   }
}
```

---

### 9. Использование неизменяемых полей класса. Преимущества неизменяемых объектов

См пункт 8

---

### 10. Функциональное программирование. Понятие инварианта класса. Примеры

Функциональное программирование — это парадигма программирования, которая делает упор на использование чистых функций, неизменяемых данных и декларативного стиля программирования.

Инвариант класса — это условие или свойство, которое должно быть истинным для всех экземпляров класса в любой момент времени. Он определяет ограничения или правила, управляющие допустимым состоянием объектов этого класса.

Пример, когда баланс в банке всегда неотрицательный:

```java
class BankAccount {
   private int balance;

   public BankAccount(int initialBalance) {
      if (initialBalance >= 0) {
         this.balance = initialBalance;
      } else {
         throw new IllegalArgumentException("Initial balance cannot be negative");
      }
   }

   public void deposit(int amount) {
      if (amount >= 0) {
         balance += amount;
      } else {
         throw new IllegalArgumentException("Deposit amount cannot be negative");
      }
   }

   public void withdraw(int amount) {
      if (amount >= 0 && amount <= balance) {
         balance -= amount;
      } else {
         throw new IllegalArgumentException("Invalid withdrawal amount");
      }
   }

   public int getBalance() {
      return balance;
   }
}
```

---

### 11. Особенности многопоточной работы в Джава, использование final для полей данных для обеспечения потокобезопасности

Поле с ключевым словом `final` неизменяемо, а потому есть преимущества во время многопоточности:

1. Неизменяемость: неизменяемые поля по своей сути потокобезопасны, поскольку их нельзя изменить, что устраняет необходимость в синхронизации.
2. Безопасность инициализации: все потоки будут видеть правильно инициализированное значение, предотвращая потенциальную гонку данных или несогласованное состояние.

Пример использования `final`:

```java
public final class ImmutableClass { // не может иметь наследников
   private final int value;  // не может быть изменено

   public ImmutableClass(int value) {
      this.value = value;
   }

   public int getValue() {
      return value;
   }
}
```

---

### 12. Основное назначение паттерна “Строитель” (Builder) для разработки программ на языке Джава

Шаблон Builder — это порождающий шаблон проектирования, который позволяет шаг за шагом создавать сложные объекты. Это особенно полезно, когда есть много необязательных параметров или сложный процесс построения, связанный с созданием объекта.

Основная цель шаблона Builder — позволить лего создавать различные представления или варианты объекта.

Пример:

```java
public class Pizza {
   private String crust;
   private String sauce;
   private List<String> toppings;

   private Pizza(Builder builder) {
      this.crust = builder.crust;
      this.sauce = builder.sauce;
      this.toppings = builder.toppings;
   }

   // Getters...

   public static class Builder {
      private String crust;
      private String sauce;
      private List<String> toppings;

      public Builder() {
         this.toppings = new ArrayList<>();
      }

      public Builder crust(String crust) {
         this.crust = crust;
         return this;
      }

      public Builder sauce(String sauce) {
         this.sauce = sauce;
         return this;
      }

      public Builder toppings(String... toppings) {
         this.toppings.addAll(Arrays.asList(toppings));
         return this;
      }

      public Pizza build() {
         return new Pizza(this);
      }
   }
}
```

```java
Pizza pizza = new Pizza.Builder()
                  .crust("thin")
                  .sauce("tomato")
                  .toppings("cheese", "mushrooms", "pepperoni")
                  .build();
```

---

### 13. Стандартные функциональные интерфейсы в Джава и их методы:

Находятся в пакете `java.util.function`

1. `Runnable`:

   -  `void run()`: Выполняет действие

1. `Consumer<T>`:

   -  `void accept(T t)`: Принимает аргумент

1. `BiConsumer<T, U>`:

   -  `void accept(T t, U u)`: Принимает 2 аргумента

1. `Predicate<T>`:

   -  `boolean test(T t)`: Оценивает условие и возвращает его результат

1. `BiPredicate<T, U>`:

   -  `boolean test(T t, U u)`: Оценивает условие от двух аргументов и возвращает его результат

1. `Supplier<T>`:

   -  `T get()`: Возвращает результат

1. `UnaryOperator<T>`:

   -  `T apply(T t)`: Аргумент и возвращаемое значение одного типа

1. `BinaryOperator<T>`:

   -  `T apply(T t1, T t2)`: Два аргумента и возвращаемое значение одного типа

1. `Function<T, R>`:

   -  `R apply(T t)`: Принимает аргумент и возвращает результат

1. `BiFunction<T, U, R>`:

   -  `R apply(T t, U u)`: Принимает 2 аргумента и возвращает результат

---

### 14. Потоки Stream API в Джава и их использование

---

### 15. Статический импорт и его использование для программирования Stream API

---

### 16. Назначение метода stream() интерфейса Collection. Примеры

---

### 17. Работа со Stream API. Нетерминальные операции потока Stream:, назначение и использование

---

### 18. Работа со Stream API. Терминальные операции, назначение и использование. Примеры

---

### 19. Интерфейс Splititerator и его методы

---

### 20. Понятие многопоточности и написание многопоточных программ на языке Джава

---

### 21. Потоки (threads) в Джава. Создание потоков в Джава программах Подходы к созданию потоков: через наследование и реализацию интерфейса Runnable Thread API. Запуск потока с Runnable

---

### 22. Потоки в Джава. Методы Thread API

---

### 23. Синхронизация потоков. Понятие синхронизации. Блок синхронизации

---

### 24. Использование синхронизации потоков для пары процессов producer/reader( производители/потребители)

---

### 25. Реализация блока synchronized на основе мониторов

---

### 26. Метод synchronized (lock), особенности его использования для потоков

---

### 27. Синхронизация потоков . Правила happens-before (hb)

---

### 28. Синхронизация потоков. Модификатор полей volatile и его использование

---

### 29. Синхронизация потоков. Атомарные операции. Механизм Wait/notify

---

### 30. Синхронизация потоков с использованием классов пакета java.util.concurrent.locks

---

### 31. Запуск и прерывание потоков. Приостановка и прерывание выполнения нити

---

### 32. Обработка операции прерывания потока

---

### 33. Ожидание и присоединение запущенной нити основным потоком управления

---

### 34. Жизненный цикл потока на языке Джава. Состояние потока

---

### 35. Многопоточные примитивы и их использование

---

### 36. Интерфейс Executor в Джава и его использование. ExecutorService

---

### 37. Интерфейс Future в Джава. Основное назначение использования его в программах

---

### 38. Коллекции java.util.concurrent. Состав коллекции. Основные методы

---

### 39. Потокобезопасные коллекции пакета java.util.concurrent:

---

### 40. Реализация асинхронного выполнения в Джава

---

### 41. Паттерн “Одиночка” (Singleton) и его использование в Джава программах

---

### 42. Использование статических методов для создания экземпляра объекта вместо конструкторов

---

### 43. Паттерн “Строитель” и его использование большом количестве параметров конструктора

---

### 44. Понятие dependency injection (внедрение зависимости). Преимущества использования внедрения зависимостей при написании программ на языке Джава. Преимущества этого подхода перед паттерном Одиночка

---

### 45. Преимущество использования try-с-ресурсами по сравнению с использованием try-finally. Интерфейс интерфейса AutoCloseable

---

### 46. Паттерн Декоратор (Decorator) Преимущества его использовании (например композиция по сравнению с наследованием)

---

### 47. Преимущества использования списков перед массивами

---

### 48. Основные системы сборки Gradle и Maven. Использование Gradle и основная терминология. Управление зависимостями в Gradle

---

### 49. Анатомия jar. Сканирование пакетов

---

### 50. Реализация REST API с помощью Spring Framework

---

### 51. Понятие Инверсии управления

---

### 52. Spring Boot и его использование

---

### 53. Работа с базами данных в джава приложениях. Встроенные СУБД для Джава приложений.

---

### 54. Реляционные СУБД для работы с джава приложениями. Пакет Пакет java.sql и его классы

---

### 55. Роль интерфейса JDBC для работы с джава приложениями

---

### 56. Основные компоненты JDBC API

---

### 57. JDBC URL и его использование

---

### 58. Работа JDBC драйвера

---

### 59. В чем заключается роль DI в Spring. Использования ServiceLoader

---

### 60. Интерфейс Connection. Пулы соединений

---

### 61. Принципы SOLID и их использование на Джава
